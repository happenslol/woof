use crate::errors::WoofError;
use crate::parse::{Locale, Module};
use std::fs;
use std::io::{BufWriter, Write};
use std::iter::repeat_n;
use std::path::Path;

static DEFAULT_LOCALE: &str = "en";
static VERSION: &str = env!("CARGO_PKG_VERSION");

pub fn generate(dir: &Path, locales: &[Locale], module: &Module) -> Result<(), WoofError> {
  if dir.is_file() {
    return Err(WoofError::OutputFileExists(
      dir.to_string_lossy().to_string(),
    ));
  }

  if dir.exists() {
    fs::remove_dir_all(dir)?;
  }

  fs::create_dir_all(dir)?;
  let mut locales_union = locales
    .iter()
    .map(|s| format!("\"{s}\""))
    .collect::<Vec<_>>();

  locales_union.sort();
  let locales_union = locales_union.join(" | ");

  fs::write(
    dir.join("index.ts"),
    format!(
      r#"// Code generated by woof v{VERSION}. DO NOT EDIT.
// eslint-disable
// biome-ignore-all: generated code
export type Locale = {locales_union}
export const defaultLocale = "{DEFAULT_LOCALE}"
export let getLocale: () => Locale = () => "{DEFAULT_LOCALE}"
export const setLocaleFn = (fn: () => Locale) => (getLocale = fn)
export * as m from "./root""#
    ),
  )?;

  write_module(dir, 0, module, &locales_union)
}

fn write_module(dir: &Path, depth: usize, module: &Module, locales: &str) -> Result<(), WoofError> {
  if module.messages.is_empty() && module.modules.is_empty() {
    return Ok(());
  }

  let filename = if depth == 0 { "root.ts" } else { "index.ts" };
  let f = fs::File::create(dir.join(filename))?;
  let mut f = BufWriter::new(f);

  let root_import = if depth == 0 {
    ".".to_string()
  } else {
    repeat_n("..", depth).collect::<Vec<&str>>().join("/")
  };

  writeln!(&mut f, "// Code generated by woof v{VERSION}. DO NOT EDIT.")?;
  writeln!(&mut f, "// eslint-disable")?;
  writeln!(&mut f, "// biome-ignore-all: generated code")?;

  if !module.messages.is_empty() {
    writeln!(&mut f, "import {{ getLocale }} from \"{root_import}\"")?;
  }

  for (key, message) in module.messages.iter() {
    write!(&mut f, "export const {key} = (", key = key.sanitized)?;

    if !message.interpolations.is_empty() {
      write!(&mut f, "args: {{ ")?;

      for (key, interpolation) in message.interpolations.iter() {
        write!(
          &mut f,
          "{name}: {type_}; ",
          name = key.sanitized,
          type_ = interpolation.type_.as_typescript_type()
        )?;
      }

      write!(&mut f, "}}, ")?;
    }

    writeln!(&mut f, "locale?: {locales}) => {{")?;
    writeln!(&mut f, "  const resolved = locale ?? getLocale()")?;

    for locale in message.translation.keys() {
      if let Some(template) = message.template_for_locale(locale) {
        writeln!(
          &mut f,
          "  if (resolved === \"{locale}\") return `{}`",
          template,
        )?;
      }
    }

    writeln!(&mut f, "  return `{}`", key.sanitized)?;
    writeln!(&mut f, "}}")?;
  }

  for module_name in module.modules.keys() {
    writeln!(
      &mut f,
      "export * as {name} from \"./{name}\"",
      name = module_name.sanitized
    )?;
  }

  for (module_name, module) in module.modules.iter() {
    let dir = dir.join(&module_name.sanitized);
    fs::create_dir_all(&dir)?;
    write_module(&dir, depth + 1, module, locales)?;
  }

  Ok(())
}
